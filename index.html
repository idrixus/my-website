<!doctype html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>IDRIS — Darkweb Cyber Placeholder</title>
    <meta name="robots" content="noindex,nofollow">
    <meta name="description"
        content="Dark, mysterious, cyber placeholder for Idris — minimalist: only the name, high-end visual treatment." />

    <style>
        :root {
            --bg0: #030205;
            /* near-black */
            --panel: rgba(6, 8, 10, 0.28);
            --accent-cyan: #00ffb3;
            --accent-green: #06ff3e;
            --accent-magenta: #ff00d6;
            --muted: #bcd;
        }

        /* reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        html,
        body {
            height: 100%
        }

        body {
            background: radial-gradient(1200px 600px at 10% 20%, rgba(8, 0, 18, 0.6), transparent 10%),
                radial-gradient(900px 500px at 90% 80%, rgba(0, 8, 10, 0.55), transparent 12%),
                var(--bg0);
            color: var(--muted);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Courier New', monospace;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* full-canvas layers stacking */
        canvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 0
        }

        /* single container (only name) */
        .center {
            position: relative;
            z-index: 12;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            pointer-events: none
        }

        /* svg hero text wrapper */
        .hero {
            width: min(95vw, 1200px);
            height: min(40vh, 380px);
            display: flex;
            align-items: center;
            justify-content: center
        }

        /* glow reflection under the text */
        .reflect {
            position: absolute;
            z-index: 11;
            bottom: 45%;
            left: 0;
            right: 0;
            height: 28%;
            opacity: 0.06;
            filter: blur(14px);
            pointer-events: none;
            background: linear-gradient(180deg, rgba(0, 255, 179, 0.12), rgba(255, 0, 214, 0.06));
            mix-blend-mode: screen
        }

        /* subtle vignette */
        .vign {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 20;
            background: radial-gradient(60% 60% at 50% 50%, rgba(0, 0, 0, 0) 40%, rgba(0, 0, 0, 0.6) 100%)
        }

        /* Accessibility: reduced motion */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important
            }
        }

        /* responsive */
        @media (max-width:640px) {
            .hero {
                height: min(32vh, 240px)
            }
        }
    </style>
</head>

<body>
    <!-- CANVASES: nebula (blurred blobs), matrix rain, particle net, stars, noise -->
    <canvas id="nebula"></canvas>
    <canvas id="matrix"></canvas>
    <canvas id="particles"></canvas>
    <canvas id="stars"></canvas>
    <div class="vign" aria-hidden="true"></div>

    <div class="center" role="main" aria-label="IDRIS landing">
        <div class="hero" aria-hidden="false">
            <!-- SVG text only: crisp, layered neon + chroma split + subtle glitch -->
            <svg viewBox="0 0 1200 280" preserveAspectRatio="xMidYMid meet" aria-hidden="false">
                <defs>
                    <filter id="blurLarge" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="12" result="b" />
                    </filter>
                    <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="8" result="g" />
                        <feMerge>
                            <feMergeNode in="g" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>
                    <linearGradient id="grainGrad" x1="0" x2="1">
                        <stop offset="0%" stop-color="#000" stop-opacity="0" />
                        <stop offset="100%" stop-color="#000" stop-opacity="0" />
                    </linearGradient>
                    <clipPath id="clipRect">
                        <rect x="0" y="0" width="1200" height="280" />
                    </clipPath>
                </defs>

                <g clip-path="url(#clipRect)">
                    <!-- deep core (white-ish) -->
                    <text id="coreText" x="50%" y="52%" text-anchor="middle" dominant-baseline="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="800" font-size="138"
                        fill="#eafcff" style="letter-spacing:14px; filter:url(#glow);">
                        IDRIS
                    </text>

                    <!-- cyan halo (left offset) -->
                    <text x="50%" y="52%" text-anchor="middle" dominant-baseline="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="800" font-size="138"
                        fill="none" stroke="rgba(0,255,179,0.22)" stroke-width="12"
                        style="letter-spacing:14px; transform:translateX(-8px);">
                        IDRIS
                    </text>

                    <!-- magenta halo (right offset) -->
                    <text x="50%" y="52%" text-anchor="middle" dominant-baseline="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="800" font-size="138"
                        fill="none" stroke="rgba(255,0,214,0.18)" stroke-width="12"
                        style="letter-spacing:14px; transform:translateX(8px);">
                        IDRIS
                    </text>

                    <!-- thin crisp outline -->
                    <text x="50%" y="52%" text-anchor="middle" dominant-baseline="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="900" font-size="138"
                        fill="none" stroke="rgba(255,255,255,0.06)" stroke-width="1.2" style="letter-spacing:14px;">
                        IDRIS
                    </text>

                    <!-- micro-glitch mask rectangles (animated via JS by toggling opacity on group) -->
                    <g id="glitchMask" style="mix-blend-mode:screen;opacity:0.98"></g>
                </g>
            </svg>
        </div>
        <div class="reflect" aria-hidden="true"></div>
    </div>

    <script>
        /* ======= CONFIG & UTIL ======= */
        const DPR = Math.max(1, window.devicePixelRatio || 1);
        const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const isMobile = /Mobi|Android|iPhone|iPad/.test(navigator.userAgent);

        function sizeCanv(canvas) {
            const w = Math.max(1, Math.floor(innerWidth * DPR));
            const h = Math.max(1, Math.floor(innerHeight * DPR));
            canvas.width = w; canvas.height = h; canvas.style.width = innerWidth + 'px'; canvas.style.height = innerHeight + 'px';
            return { w, h };
        }

        /* ======= NEBULA (darker, desaturated, green/purple) ======= */
        const neb = document.getElementById('nebula'); const nctx = neb.getContext('2d');
        let blobs = [];
        function initNeb() { const { w, h } = sizeCanv(neb); blobs = []; const count = isMobile ? 3 : 5; for (let i = 0; i < count; i++) { blobs.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() * 0.5 - 0.25) * (isMobile ? 0.4 : 1), vy: (Math.random() * 0.4 - 0.2) * (isMobile ? 0.4 : 1), r: Math.min(w, h) * (0.12 + Math.random() * 0.18), hue: Math.random() }); } }
        function drawNeb(t) {
            nctx.clearRect(0, 0, neb.width, neb.height); // dark base
            const g = nctx.createLinearGradient(0, 0, neb.width, neb.height);
            g.addColorStop(0, 'rgba(2,3,5,1)'); g.addColorStop(1, 'rgba(6,2,8,1)'); nctx.fillStyle = g; nctx.fillRect(0, 0, neb.width, neb.height);
            nctx.save(); nctx.globalCompositeOperation = 'lighter'; nctx.filter = 'blur(48px)';
            for (const b of blobs) { const hue = (b.hue * 360 + (t * 0.00002 * 40)) % 360; const color = `hsla(${hue},80%,40%,0.26)`; const rg = nctx.createRadialGradient(b.x, b.y, Math.max(1, b.r * 0.15), b.x, b.y, b.r); rg.addColorStop(0, color); rg.addColorStop(0.4, color.replace('0.26', '0.12')); rg.addColorStop(1, 'rgba(0,0,0,0)'); nctx.fillStyle = rg; nctx.beginPath(); nctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); nctx.fill(); }
            nctx.restore();
        }

        /* ======= MATRIX RAIN (vert green streams) ======= */
        const mat = document.getElementById('matrix'); const mctx = mat.getContext('2d');
        let cols, colSize, drops;
        function initMatrix() { const { w, h } = sizeCanv(mat); colSize = Math.max(12 * DPR, isMobile ? 10 * DPR : 14 * DPR); cols = Math.floor(w / colSize); drops = new Array(cols).fill(0).map(() => Math.floor(Math.random() * h)); }
        function drawMatrix() {
            mctx.clearRect(0, 0, mat.width, mat.height); mctx.fillStyle = 'rgba(0,0,0,0.02)'; mctx.fillRect(0, 0, mat.width, mat.height); mctx.font = `${colSize}px monospace`; mctx.textBaseline = 'top';
            for (let i = 0; i < cols; i++) {
                const x = i * colSize; const y = drops[i] * colSize; const char = String.fromCharCode(0x30A0 + Math.floor(Math.random() * 96)); mctx.fillStyle = `rgba(0,255,148,${0.18 + Math.random() * 0.32})`; mctx.fillText(char, x, y);
                drops[i] += 1; if (drops[i] * colSize > mat.height + Math.random() * 10000) drops[i] = 0;
            }
        }

        /* ======= PARTICLES + LINKS (cyber net) ======= */
        const pcan = document.getElementById('particles'); const pct = pcan.getContext('2d'); let parts = [];
        function initParts() { const { w, h } = sizeCanv(pcan); parts = []; const area = w * h; const density = isMobile ? 1 / 26000 : 1 / 16000; const count = Math.max(16, Math.floor(area * density)); for (let i = 0; i < count; i++) { parts.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() * 0.6 - 0.3) * (isMobile ? 0.45 : 1), vy: (Math.random() * 0.6 - 0.3) * (isMobile ? 0.45 : 1), r: (Math.random() * 1.6 + 0.6) * DPR, col: Math.random() }); } }
        function drawParts() {
            pct.clearRect(0, 0, pcan.width, pcan.height); const maxD = Math.min(120 * DPR, pcan.width / 6);
            for (let i = 0; i < parts.length; i++) { for (let j = i + 1; j < parts.length; j++) { const a = parts[i], b = parts[j]; const dx = a.x - b.x, dy = a.y - b.y, d = Math.hypot(dx, dy); if (d < maxD) { pct.beginPath(); pct.strokeStyle = `rgba(0,230,140,${0.06 * (1 - d / maxD)})`; pct.lineWidth = 0.6 * DPR; pct.moveTo(a.x, a.y); pct.lineTo(b.x, b.y); pct.stroke(); } } }
            for (const p of parts) { pct.beginPath(); const c = p.col < 0.33 ? '#00ffb3' : (p.col < 0.66 ? '#ff00d6' : '#7eff3b'); pct.fillStyle = c; pct.globalAlpha = 0.88; pct.arc(p.x, p.y, p.r, 0, Math.PI * 2); pct.fill(); pct.globalAlpha = 1; }
        }

        /* ======= STARS (tiny twinkle) ======= */
        const star = document.getElementById('stars'); const sctx = star.getContext('2d'); let stars = [];
        function initStars() { const { w, h } = sizeCanv(star); stars = []; const count = Math.floor((w * h) / (isMobile ? 45000 : 22000)); for (let i = 0; i < count; i++) { stars.push({ x: Math.random() * w, y: Math.random() * h, r: Math.random() * 1.4 * DPR, a: 0.2 + Math.random() * 0.9, tw: Math.random() * 3000 + 900 }); } }
        function drawStars(t) { sctx.clearRect(0, 0, star.width, star.height); for (const st of stars) { const a = st.a * (0.5 + 0.5 * Math.sin((t % st.tw) / st.tw * Math.PI * 2)); sctx.globalAlpha = a * 0.9; sctx.fillStyle = '#fff'; sctx.beginPath(); sctx.arc(st.x, st.y, st.r, 0, Math.PI * 2); sctx.fill(); } sctx.globalAlpha = 1; }

        /* ======= CORE LOOP ======= */
        let last = performance.now(); let raf;
        function step(now) {
            const dt = now - last; last = now;
            // move blobs
            for (const b of blobs) { b.x += b.vx * Math.max(0.2, dt * 0.06); b.y += b.vy * Math.max(0.2, dt * 0.06); if (b.x < -b.r) b.x = neb.width + b.r; if (b.x > neb.width + b.r) b.x = -b.r; if (b.y < -b.r) b.y = neb.height + b.r; if (b.y > neb.height + b.r) b.y = -b.r; }
            // move parts
            for (const p of parts) { p.x += p.vx * Math.max(0.2, dt * 0.06); p.y += p.vy * Math.max(0.2, dt * 0.06); if (p.x < -10) p.x = pcan.width + 10; if (p.x > pcan.width + 10) p.x = -10; if (p.y < -10) p.y = pcan.height + 10; if (p.y > pcan.height + 10) p.y = -10; }

            // draw
            drawNeb(now); drawStars(now); drawParts(); if (!reduced) drawMatrix();

            raf = requestAnimationFrame(step);
        }

        /* ======= interaction: slight parallax via mouse ======= */
        let mouse = { x: null, y: null }; let tThrottle = 0;
        window.addEventListener('mousemove', (e) => { if (reduced) return; const now = Date.now(); if (now - tThrottle > 14) { mouse.x = e.clientX; mouse.y = e.clientY; tThrottle = now; const tx = (mouse.x - innerWidth / 2) * 0.02 * DPR; const ty = (mouse.y - innerHeight / 2) * 0.02 * DPR; neb.style.transform = `translate3d(${tx * 0.12}px,${ty * 0.08}px,0)`; pcan.style.transform = `translate3d(${tx * 0.4}px,${ty * 0.3}px,0)`; star.style.transform = `translate3d(${tx * 0.06}px,${ty * 0.04}px,0)`; mat.style.transform = `translate3d(${tx * 0.2}px,${ty * 0.18}px,0)`; } });

        /* micro-glitch: flashes slices across the SVG text for realism */
        (function microGlitch() {
            const g = document.getElementById('glitchMask'); if (!g) return; function makeSlice(y, h, opacity, delay) { const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.setAttribute('x', 0); rect.setAttribute('y', y); rect.setAttribute('width', 1200); rect.setAttribute('height', h); rect.setAttribute('fill', 'rgba(255,255,255,' + opacity + ')'); rect.style.mixBlendMode = 'screen'; rect.style.opacity = '0'; g.appendChild(rect); setTimeout(() => { rect.style.transition = 'opacity 140ms linear, transform 200ms linear'; rect.style.opacity = '1'; rect.style.transform = 'translateX(' + (Math.random() > 0.5 ? 20 : -20) + 'px)'; setTimeout(() => { rect.style.opacity = '0'; setTimeout(() => rect.remove(), 220) }, 120 + Math.random() * 220) }, delay); }
            function loop() { if (reduced) { setTimeout(loop, 1200); return; } const slices = 1 + Math.floor(Math.random() * 3); for (let i = 0; i < slices; i++) { const y = Math.random() * 180; const h = 6 + Math.random() * 28; const op = 0.07 + Math.random() * 0.16; makeSlice(y, h, op, Math.random() * 300); } const next = 800 + Math.random() * 2200; setTimeout(loop, next); } loop();
        })();

        /* ======= init & resize handling ======= */
        function initAll() { initNeb(); initParts(); initStars(); initMatrix(); cancelAnimationFrame(raf); last = performance.now(); if (!reduced) raf = requestAnimationFrame(step); else { drawNeb(performance.now()); drawStars(performance.now()); drawParts(); } }
        initAll();
        let rto; window.addEventListener('resize', () => { clearTimeout(rto); rto = setTimeout(() => { initAll(); }, 140); });

        /* pause when hidden */
        document.addEventListener('visibilitychange', () => { if (document.hidden) cancelAnimationFrame(raf); else { last = performance.now(); raf = requestAnimationFrame(step); } });

    </script>
</body>

</html>