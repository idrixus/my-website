<!doctype html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>YOUSSEF — Blacknet</title>
    <meta name="robots" content="noindex,nofollow">
    <meta name="description"
        content="YOUSSEF — Darkweb hacker-style landing. Single-word identity; black, glitchy, terminal-driven, ominous." />

    <style>
        /* ===========================
       THEME: Darkweb Hacker / Scary
       - Only visible text: YOUSSEF
       - Terminal, corrupted, glitch, film grain
       - Heavy visual polish, single-file
       =========================== */

        :root {
            --bg: #020203;
            --deep: #050507;
            --term-bg: rgba(0, 0, 0, 0.6);
            --accent-red: #ff0033;
            --accent-green: #00ff5a;
            --accent-magenta: #ff00d6;
            --ghost: #cfeefc;
            --glass: rgba(255, 255, 255, 0.03);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        html,
        body {
            height: 100%
        }

        body {
            background: radial-gradient(800px 420px at 12% 18%, rgba(8, 0, 12, 0.6), transparent 6%),
                radial-gradient(700px 360px at 92% 82%, rgba(2, 8, 4, 0.5), transparent 8%),
                var(--bg);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Courier New', monospace;
            color: var(--ghost);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* canvases stack */
        canvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 0
        }

        /* main center (only name) */
        .center {
            position: relative;
            z-index: 40;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            pointer-events: none
        }

        .hero {
            width: min(94vw, 1300px);
            height: min(46vh, 520px);
            display: flex;
            align-items: center;
            justify-content: center
        }

        /* large SVG text: distorted, jagged / scary glyphs via filters */
        svg {
            width: 100%;
            height: 100%
        }

        /* reflection / floor glow */
        .ref {
            position: absolute;
            z-index: 39;
            bottom: 44%;
            left: 0;
            right: 0;
            height: 26%;
            opacity: 0.08;
            filter: blur(14px);
            pointer-events: none;
            background: linear-gradient(180deg, rgba(255, 0, 50, 0.08), rgba(0, 255, 120, 0.03));
            mix-blend-mode: screen
        }

        /* top vignette and film grain */
        .vign {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 50;
            background: radial-gradient(60% 60% at 50% 50%, rgba(0, 0, 0, 0) 40%, rgba(0, 0, 0, 0.7) 100%)
        }

        /* tiny film grain overlay using CSS noise (data URL) */
        :root {
            --noise: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60"><filter id="n"><feTurbulence baseFrequency="0.8" numOctaves="2" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23n)" opacity="0.03"/></svg>')
        }

        .grain {
            position: fixed;
            inset: 0;
            z-index: 60;
            pointer-events: none;
            background-image: var(--noise);
            mix-blend-mode: overlay;
            opacity: 0.12
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important
            }
        }

        /* responsive */
        @media (max-width:640px) {
            .hero {
                height: min(34vh, 260px)
            }
        }

        /* tiny accessibility helper: focus outline in case of keyboard users */
        :focus {
            outline: 2px solid rgba(255, 255, 255, 0.06);
            outline-offset: 3px
        }
    </style>
</head>

<body>

    <!-- background layers: corrupted nebula, scanlines, matrix rain, particles, stars -->
    <canvas id="nebula"></canvas>
    <canvas id="scanlines"></canvas>
    <canvas id="matrix"></canvas>
    <canvas id="particles"></canvas>
    <canvas id="stars"></canvas>

    <div class="vign" aria-hidden="true"></div>
    <div class="grain" aria-hidden="true"></div>

    <div class="center" role="main" aria-label="YOUSSEF">
        <div class="hero" aria-hidden="false">
            <!-- Heavy scary SVG text: jagged distort + chroma + glitch slices inserted by JS -->
            <svg viewBox="0 0 1400 420" preserveAspectRatio="xMidYMid meet" aria-hidden="false">
                <defs>
                    <!-- creepy distort filter -->
                    <filter id="distort" x="-20%" y="-20%" width="140%" height="140%">
                        <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" stitchTiles="stitch"
                            result="t" />
                        <feDisplacementMap in="SourceGraphic" in2="t" scale="18" xChannelSelector="R"
                            yChannelSelector="G" />
                    </filter>

                    <!-- heavy bloom for cinematic effect -->
                    <filter id="heavyBloom" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="18" result="b" />
                        <feMerge>
                            <feMergeNode in="b" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>

                    <!-- scanline gradient for subtle CRT look -->
                    <linearGradient id="scan" x1="0" x2="0" y1="0" y2="1">
                        <stop offset="0%" stop-color="rgba(255,255,255,0.03)" />
                        <stop offset="100%" stop-color="rgba(255,255,255,0)" />
                    </linearGradient>

                    <!-- clip area -->
                    <clipPath id="clipArea">
                        <rect x="0" y="0" width="1400" height="420" />
                    </clipPath>
                </defs>

                <!-- layered text: core + left chroma + right chroma + jagged thin stroke -->
                <g clip-path="url(#clipArea)">
                    <text id="core" x="50%" y="52%" dominant-baseline="middle" text-anchor="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="900" font-size="160"
                        fill="#ffeef2" style="letter-spacing:18px; filter:url(#heavyBloom);">YOUSSEF</text>

                    <text x="50%" y="52%" dominant-baseline="middle" text-anchor="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="900" font-size="160"
                        fill="none" stroke="rgba(0,255,90,0.24)" stroke-width="14"
                        style="letter-spacing:18px; transform:translateX(-12px) skewX(-6deg);">YOUSSEF</text>

                    <text x="50%" y="52%" dominant-baseline="middle" text-anchor="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="900" font-size="160"
                        fill="none" stroke="rgba(255,0,70,0.18)" stroke-width="14"
                        style="letter-spacing:18px; transform:translateX(12px) skewX(6deg);">YOUSSEF</text>

                    <text x="50%" y="52%" dominant-baseline="middle" text-anchor="middle"
                        font-family="ui-monospace, 'Courier New', monospace" font-weight="900" font-size="160"
                        fill="none" stroke="rgba(255,255,255,0.06)" stroke-width="1.2"
                        style="letter-spacing:18px;">YOUSSEF</text>

                </g>
            </svg>
        </div>

        <div class="ref" aria-hidden="true"></div>
    </div>

    <script>
        /* ==================================================
           Darkweb Hacker Redesign: "Blacknet"
           - Only visible word: YOUSSEF
           - Scary / corrupted typography via SVG filters
           - Layers: nebula (blobs), matrix rain, scanlines, particles, stars
           - Micro-glitch slices over the SVG text
           - Terminal overlay (hidden to viewers, used for realism in background animations)
           - This file is intentionally long & commented for maintainability
           ================================================== */

        const DPR = Math.max(1, window.devicePixelRatio || 1);
        const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const isMobile = /Mobi|Android|iPhone|iPad/.test(navigator.userAgent);

        function fit(canvas) { const w = Math.max(1, Math.floor(innerWidth * DPR)); const h = Math.max(1, Math.floor(innerHeight * DPR)); canvas.width = w; canvas.height = h; canvas.style.width = innerWidth + 'px'; canvas.style.height = innerHeight + 'px'; return { w, h }; }

        /* ---------------- nebula (dark) ---------------- */
        const neb = document.getElementById('nebula'); const nctx = neb.getContext('2d'); let blobs = [];
        function initNeb() { const { w, h } = fit(neb); blobs = []; const count = isMobile ? 3 : 6; for (let i = 0; i < count; i++) { blobs.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() * 0.6 - 0.3) * (isMobile ? 0.5 : 1), vy: (Math.random() * 0.4 - 0.2) * (isMobile ? 0.5 : 1), r: Math.min(w, h) * (0.12 + Math.random() * 0.25), hue: Math.random() }); } }
        function drawNeb(t) { nctx.clearRect(0, 0, neb.width, neb.height); const g = nctx.createLinearGradient(0, 0, neb.width, neb.height); g.addColorStop(0, 'rgba(2,2,6,1)'); g.addColorStop(1, 'rgba(8,2,12,1)'); nctx.fillStyle = g; nctx.fillRect(0, 0, neb.width, neb.height); nctx.save(); nctx.globalCompositeOperation = 'lighter'; nctx.filter = 'blur(44px)'; for (const b of blobs) { const hue = (b.hue * 360 + (t * 0.00002 * 40)) % 360; const col = `hsla(${hue},72%,38%,0.28)`; const rg = nctx.createRadialGradient(b.x, b.y, Math.max(1, b.r * 0.08), b.x, b.y, b.r); rg.addColorStop(0, col); rg.addColorStop(0.35, col.replace('0.28', '0.12')); rg.addColorStop(1, 'rgba(0,0,0,0)'); nctx.fillStyle = rg; nctx.beginPath(); nctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); nctx.fill(); } nctx.restore(); }

        /* ---------------- scanlines ---------------- */
        const scan = document.getElementById('scanlines'); const sctx = scan.getContext('2d');
        function initScan() { fit(scan); }
        function drawScan() { sctx.clearRect(0, 0, scan.width, scan.height); sctx.globalAlpha = 0.035; const step = Math.max(2 * DPR, 1); for (let y = 0; y < scan.height; y += step * 3) { sctx.fillStyle = 'rgba(255,255,255,0.02)'; sctx.fillRect(0, y, scan.width, step); } sctx.globalAlpha = 1; }

        /* ---------------- matrix rain ---------------- */
        const matrix = document.getElementById('matrix'); const mctx = matrix.getContext('2d'); let cols = 0; let drops = [];
        function initMatrix() { const { w, h } = fit(matrix); const size = Math.max(12 * DPR, isMobile ? 10 * DPR : 14 * DPR); cols = Math.floor(w / size); drops = new Array(cols).fill(0).map(() => Math.floor(Math.random() * h / size)); }
        function drawMatrix() { mctx.clearRect(0, 0, matrix.width, matrix.height); const size = Math.max(12 * DPR, isMobile ? 10 * DPR : 14 * DPR); mctx.font = `${size}px monospace`; mctx.textBaseline = 'top'; for (let i = 0; i < cols; i++) { const x = i * size; const y = drops[i] * size; const ch = String.fromCharCode(0x30A0 + Math.floor(Math.random() * 96)); mctx.fillStyle = `rgba(0,255,150,${0.12 + Math.random() * 0.36})`; mctx.fillText(ch, x, y); drops[i] += 1; if (drops[i] * size > matrix.height + Math.random() * 10000) drops[i] = 0; } }

        /* ---------------- particles ---------------- */
        const parts = document.getElementById('particles'); const pctx = parts.getContext('2d'); let nodes = [];
        function initParts() { const { w, h } = fit(parts); nodes = []; const area = w * h; const density = isMobile ? 1 / 26000 : 1 / 16000; const cnt = Math.max(18, Math.floor(area * density)); for (let i = 0; i < cnt; i++) { nodes.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() * 0.6 - 0.3) * (isMobile ? 0.45 : 1), vy: (Math.random() * 0.6 - 0.3) * (isMobile ? 0.45 : 1), r: (Math.random() * 1.6 + 0.6) * DPR, c: Math.random() }); } }
        function drawParts() { pctx.clearRect(0, 0, parts.width, parts.height); const maxD = Math.min(140 * DPR, parts.width / 6); for (let i = 0; i < nodes.length; i++) { for (let j = i + 1; j < nodes.length; j++) { const a = nodes[i], b = nodes[j]; const dx = a.x - b.x, dy = a.y - b.y; const d = Math.hypot(dx, dy); if (d < maxD) { pctx.beginPath(); pctx.strokeStyle = `rgba(0,255,160,${0.06 * (1 - d / maxD)})`; pctx.lineWidth = 0.6 * DPR; pctx.moveTo(a.x, a.y); pctx.lineTo(b.x, b.y); pctx.stroke(); } } } for (const n of nodes) { pctx.beginPath(); const col = n.c < 0.33 ? '#00ff5a' : (n.c < 0.66 ? '#ff00d6' : '#7eff2f'); pctx.fillStyle = col; pctx.globalAlpha = 0.9; pctx.arc(n.x, n.y, n.r, 0, Math.PI * 2); pctx.fill(); pctx.globalAlpha = 1; } }

        /* ---------------- stars ---------------- */
        const stars = document.getElementById('stars'); const stx = stars.getContext('2d'); let starArr = [];
        function initStars() { const { w, h } = fit(stars); starArr = []; const count = Math.floor((w * h) / (isMobile ? 42000 : 22000)); for (let i = 0; i < count; i++) { starArr.push({ x: Math.random() * w, y: Math.random() * h, r: Math.random() * 1.4 * DPR, a: 0.2 + Math.random() * 0.9, tw: Math.random() * 3000 + 1000 }); } }
        function drawStars(t) { stx.clearRect(0, 0, stars.width, stars.height); for (const s of starArr) { const alpha = s.a * (0.5 + 0.5 * Math.sin((t % s.tw) / s.tw * Math.PI * 2)); stx.globalAlpha = alpha * 0.9; stx.fillStyle = '#fff'; stx.beginPath(); stx.arc(s.x, s.y, s.r, 0, Math.PI * 2); stx.fill(); } stx.globalAlpha = 1; }

        /* ---------------- micro glitch slices on SVG text ---------------- */
        (function microGlitch() {
            const svg = document.querySelector('svg'); if (!svg) return; function makeSlice(y, h, op, delay) { const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect'); rect.setAttribute('x', 0); rect.setAttribute('y', y); rect.setAttribute('width', 1400); rect.setAttribute('height', h); rect.setAttribute('fill', `rgba(255,255,255,${op})`); rect.style.mixBlendMode = 'screen'; rect.style.opacity = '0'; svg.appendChild(rect); setTimeout(() => { rect.style.transition = 'opacity 120ms linear, transform 160ms linear'; rect.style.opacity = '1'; rect.style.transform = 'translateX(' + (Math.random() > 0.5 ? 22 : -22) + 'px)'; setTimeout(() => { rect.style.opacity = '0'; setTimeout(() => rect.remove(), 160) }, 100 + Math.random() * 260); }, delay); }
            function loop() { if (reduced) { setTimeout(loop, 1200); return; } const s = 1 + Math.floor(Math.random() * 3); for (let i = 0; i < s; i++) { makeSlice(Math.random() * 260, 6 + Math.random() * 28, 0.06 + Math.random() * 0.16, Math.random() * 480); } setTimeout(loop, 700 + Math.random() * 2800); } loop();
        })();

        /* ---------------- main animation loop ---------------- */
        let last = performance.now(); let RAF;
        function animate(now) {
            const dt = now - last; last = now; for (const b of blobs) { b.x += b.vx * Math.max(0.2, dt * 0.06); b.y += b.vy * Math.max(0.2, dt * 0.06); if (b.x < -b.r) b.x = neb.width + b.r; if (b.x > neb.width + b.r) b.x = -b.r; if (b.y < -b.r) b.y = neb.height + b.r; if (b.y > neb.height + b.r) b.y = -b.r; } for (const n of nodes) { n.x += n.vx * Math.max(0.2, dt * 0.06); n.y += n.vy * Math.max(0.2, dt * 0.06); if (n.x < -10) n.x = parts.width + 10; if (n.x > parts.width + 10) n.x = -10; if (n.y < -10) n.y = parts.height + 10; if (n.y > parts.height + 10) n.y = -10; }
            drawNeb(now); drawStars(now); drawParts(); if (!reduced) drawMatrix(); drawScan(); RAF = requestAnimationFrame(animate);
        }

        /* ---------------- parallax on mouse ---------------- */
        let lastMouse = 0; window.addEventListener('mousemove', (e) => { if (reduced) return; const now = Date.now(); if (now - lastMouse > 14) { lastMouse = now; const tx = (e.clientX - innerWidth / 2) * 0.02 * DPR; const ty = (e.clientY - innerHeight / 2) * 0.02 * DPR; neb.style.transform = `translate3d(${tx * 0.08}px, ${ty * 0.06}px,0)`; parts.style.transform = `translate3d(${tx * 0.42}px, ${ty * 0.32}px,0)`; stars.style.transform = `translate3d(${tx * 0.06}px, ${ty * 0.04}px,0)`; matrix.style.transform = `translate3d(${tx * 0.18}px, ${ty * 0.12}px,0)`; scan.style.transform = `translate3d(${tx * 0.04}px, ${ty * 0.03}px,0)`; } });

        /* ---------------- init & resize ---------------- */
        function initAll() { initNeb(); initScan(); initMatrix(); initParts(); initStars(); cancelAnimationFrame(RAF); last = performance.now(); if (!reduced) RAF = requestAnimationFrame(animate); else { drawNeb(performance.now()); drawStars(performance.now()); drawParts(); drawScan(); } }
        initAll(); let rto; window.addEventListener('resize', () => { clearTimeout(rto); rto = setTimeout(() => { initAll(); }, 160); });

        document.addEventListener('visibilitychange', () => { if (document.hidden) cancelAnimationFrame(RAF); else { last = performance.now(); RAF = requestAnimationFrame(animate); } });

        /* ----------------- final notes ----------------- */
        /* Packaging to sell:
           - Include: index.html (this), README, LICENSE, preview WebM (8s), 4K hero screenshot, source Figma/SVG, variable font license.
           - Legal: get written assignment & license specifying exclusivity to buyer.
           - Commercial pitch: 1-page one-liner, 30s demo, and pricing tiers.
        */

    </script>

</body>

</html>